#cloud-config
# Cloud-init configuration for TDX Recording Oracle VM

hostname: {{ vm_name }}

ssh_pwauth: true

users:
  - name: {{ guest_user }}
    groups: [sudo, docker]
    shell: /bin/bash
    sudo: ['ALL=(ALL) NOPASSWD:ALL']
    lock_passwd: false
    plain_text_passwd: {{ guest_password }}
{% if guest_ssh_authorized_key %}
    ssh_authorized_keys:
      - {{ guest_ssh_authorized_key }}
{% endif %}

# Install Docker and docker-compose
package_update: true
packages:
  - docker.io
  - docker-compose-v2

write_files:
  - path: /opt/recording-oracle/tdx-attestation-proxy.py
    permissions: '0755'
    content: |
      #!/usr/bin/env python3
      """TDX Attestation Proxy - provides HTTP API for TDX quote generation."""
      import http.server
      import json
      import os
      import base64
      import uuid

      TDX_DEVICE = os.environ.get('TDX_DEVICE_PATH', '/dev/tdx_guest')
      TSM_REPORT_PATH = '/sys/kernel/config/tsm/report'
      PORT = int(os.environ.get('TDX_PROXY_PORT', '8081'))

      def generate_tdx_quote(report_data=None):
          """Generate TDX quote using configfs TSM interface."""
          if report_data is None:
              report_data = bytes(64)  # 64 zero bytes as default report data

          # Create unique report entry
          report_name = f'quote_{uuid.uuid4().hex[:8]}'
          report_path = os.path.join(TSM_REPORT_PATH, report_name)

          try:
              os.makedirs(report_path, exist_ok=True)

              # Write report data (inblob)
              with open(os.path.join(report_path, 'inblob'), 'wb') as f:
                  f.write(report_data)

              # Read the quote (outblob)
              with open(os.path.join(report_path, 'outblob'), 'rb') as f:
                  quote = f.read()

              # Extract measurements from quote
              # TDX quote structure: header + body with measurements
              measurements = extract_measurements(quote)

              return {
                  'quote': base64.b64encode(quote).decode(),
                  'quote_size': len(quote),
                  'report_data': base64.b64encode(report_data).decode(),
                  'measurements': measurements
              }
          finally:
              # Cleanup: remove the report entry
              try:
                  os.rmdir(report_path)
              except:
                  pass

      def extract_measurements(quote):
          """Extract MRTD and RTMRs from TDX quote."""
          # TDX Quote v4 structure offsets (approximate)
          # Header is 48 bytes, then TD Report starts
          # MRTD is at offset 528 (48 bytes)
          # RTMRs start at offset 576 (4 x 48 bytes each)
          try:
              if len(quote) < 768:
                  return {}

              mrtd = quote[528:576]
              rtmr0 = quote[576:624]
              rtmr1 = quote[624:672]
              rtmr2 = quote[672:720]
              rtmr3 = quote[720:768]

              return {
                  'mrtd': mrtd.hex(),
                  'rtmr0': rtmr0.hex(),
                  'rtmr1': rtmr1.hex(),
                  'rtmr2': rtmr2.hex(),
                  'rtmr3': rtmr3.hex()
              }
          except Exception:
              return {}

      class TDXHandler(http.server.BaseHTTPRequestHandler):
          def do_GET(self):
              if self.path == '/status':
                  # Check both device and configfs availability
                  device_available = os.path.exists(TDX_DEVICE)
                  tsm_available = os.path.exists(TSM_REPORT_PATH)
                  self.send_response(200)
                  self.send_header('Content-Type', 'application/json')
                  self.end_headers()
                  self.wfile.write(json.dumps({
                      'available': device_available or tsm_available,
                      'device': TDX_DEVICE,
                      'tsm_path': TSM_REPORT_PATH,
                      'tsm_available': tsm_available
                  }).encode())
              elif self.path == '/quote':
                  try:
                      result = generate_tdx_quote()
                      self.send_response(200)
                      self.send_header('Content-Type', 'application/json')
                      self.end_headers()
                      self.wfile.write(json.dumps(result).encode())
                  except Exception as e:
                      self.send_response(500)
                      self.send_header('Content-Type', 'application/json')
                      self.end_headers()
                      self.wfile.write(json.dumps({'error': str(e)}).encode())
              else:
                  self.send_response(404)
                  self.end_headers()

      if __name__ == '__main__':
          server = http.server.HTTPServer(('0.0.0.0', PORT), TDXHandler)
          print(f'TDX Attestation Proxy listening on port {PORT}')
          server.serve_forever()

  - path: /etc/systemd/system/tdx-attestation-proxy.service
    permissions: '0644'
    content: |
      [Unit]
      Description=TDX Attestation Proxy
      After=network.target

      [Service]
      Type=simple
      ExecStart=/usr/bin/python3 /opt/recording-oracle/tdx-attestation-proxy.py
      Restart=always

      [Install]
      WantedBy=multi-user.target

  - path: /opt/recording-oracle/.env
    permissions: '0600'
    content: |
      # Secrets for recording-oracle (replace in production)
      JWT_PRIVATE_KEY=-----BEGIN EC PRIVATE KEY-----\nMHcCAQEEIO3jow3dIM2HoetSGZySj4jOaGzL3/mqPn2qo4CLRSfloAoGCCqGSM49\nAwEHoUQDQgAEjJ0hc6Q+vK/Ko5LP3C8TDGZqFZtpP/iF6ATs+5vfLZ0LLX+yqzBU\nLydATxczxyUe5vxvXV11BhPfs17J2Rf52A==\n-----END EC PRIVATE KEY-----
      JWT_PUBLIC_KEY=-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEjJ0hc6Q+vK/Ko5LP3C8TDGZqFZtp\nP/iF6ATs+5vfLZ0LLX+yqzBULydATxczxyUe5vxvXV11BhPfs17J2Rf52A==\n-----END PUBLIC KEY-----
      AES_ENCRYPTION_KEY=E4MyMuBHDUNQa396GL3q8AClLPkg3JmV
      WEB3_PRIVATE_KEY=0x0000000000000000000000000000000000000000000000000000000000000001
      RPC_URL_POLYGON_AMOY=https://rpc-amoy.polygon.technology
      RPC_URL_LOCALHOST=http://localhost:8545
      ALCHEMY_API_KEY=demo

  - path: /opt/recording-oracle/docker-compose.yml
    permissions: '0644'
    content: |
      services:
        postgres:
          image: postgres:15-alpine
          environment:
            POSTGRES_USER: postgres
            POSTGRES_PASSWORD: postgres
            POSTGRES_DB: recording
          volumes:
            - postgres_data:/var/lib/postgresql/data
          healthcheck:
            test: ["CMD-SHELL", "pg_isready -U postgres"]
            interval: 5s
            timeout: 5s
            retries: 5

        minio:
          image: minio/minio:latest
          command: server /data --console-address ":9001"
          environment:
            MINIO_ROOT_USER: minioadmin
            MINIO_ROOT_PASSWORD: minioadmin
          volumes:
            - minio_data:/data
          healthcheck:
            test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
            interval: 5s
            timeout: 5s
            retries: 5

        minio-init:
          image: minio/mc:latest
          depends_on:
            minio:
              condition: service_healthy
          entrypoint: >
            /bin/sh -c "
              mc alias set myminio http://minio:9000 minioadmin minioadmin;
              mc mb --ignore-existing myminio/recordings;
              mc anonymous set public myminio/recordings;
              exit 0;
            "

        recording-oracle:
          image: {{ recording_oracle_image }}
          depends_on:
            postgres:
              condition: service_healthy
            minio:
              condition: service_healthy
          ports:
            - "{{ recording_oracle_port }}:{{ recording_oracle_port }}"
          extra_hosts:
            - "host.docker.internal:host-gateway"
          env_file:
            - .env
          environment:
            NODE_ENV: development
            HOST: 0.0.0.0
            PORT: "{{ recording_oracle_port }}"
            # Database
            POSTGRES_HOST: postgres
            POSTGRES_PORT: "5432"
            POSTGRES_USER: postgres
            POSTGRES_PASSWORD: postgres
            POSTGRES_DATABASE: recording
            POSTGRES_SSL: "false"
            # S3/Minio
            S3_ENDPOINT: minio
            S3_PORT: "9000"
            S3_ACCESS_KEY: minioadmin
            S3_SECRET_KEY: minioadmin
            S3_BUCKET: recordings
            S3_USE_SSL: "false"
            # TDX
            TDX_ATTESTATION_PROXY_URL: http://host.docker.internal:8081

      volumes:
        postgres_data:
        minio_data:

  - path: /etc/systemd/system/recording-oracle.service
    permissions: '0644'
    content: |
      [Unit]
      Description=Recording Oracle Stack
      After=docker.service
      Requires=docker.service

      [Service]
      Type=oneshot
      RemainAfterExit=yes
      WorkingDirectory=/opt/recording-oracle
      ExecStart=/usr/bin/docker compose up -d
      ExecStop=/usr/bin/docker compose down

      [Install]
      WantedBy=multi-user.target

runcmd:
  # Start TDX attestation proxy
  - systemctl daemon-reload
  - systemctl enable tdx-attestation-proxy
  - systemctl start tdx-attestation-proxy
  # Ensure docker is running
  - systemctl enable docker
  - systemctl start docker
  # Start recording oracle stack
  - systemctl enable recording-oracle
  - systemctl start recording-oracle

final_message: |
  Recording Oracle TDX VM is ready!

  TDX Attestation Proxy: http://localhost:8081
  Recording Oracle: http://localhost:{{ recording_oracle_port }}
  Minio Console: http://localhost:9001

  To check TDX status: curl http://localhost:8081/status
  To get TDX quote: curl http://localhost:8081/quote
