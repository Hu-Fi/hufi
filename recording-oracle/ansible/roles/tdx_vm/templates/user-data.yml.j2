#cloud-config
# Cloud-init configuration for TDX Recording Oracle VM

hostname: {{ vm_name }}

ssh_pwauth: true

users:
  - name: {{ guest_user }}
    groups: [sudo, docker]
    shell: /bin/bash
    sudo: ['ALL=(ALL) NOPASSWD:ALL']
    lock_passwd: false
    plain_text_passwd: {{ guest_password }}
{% if guest_ssh_authorized_key %}
    ssh_authorized_keys:
      - {{ guest_ssh_authorized_key }}
{% endif %}

# Install Docker and docker-compose
package_update: true
packages:
  - docker.io
  - docker-compose-v2

write_files:
  - path: /opt/recording-oracle/tdx-attestation-proxy.py
    permissions: '0755'
    content: |
      #!/usr/bin/env python3
      """TDX Attestation Proxy - HTTP API for TDX quote generation via TSM configfs."""
      import http.server
      import json
      import os
      import base64
      import uuid

      TSM_REPORT_PATH = "/sys/kernel/config/tsm/report"
      PORT = int(os.environ.get("TDX_PROXY_PORT", "8081"))

      def get_tdx_quote(report_data=None):
          """Generate TDX Quote using TSM configfs interface."""
          if report_data is None:
              report_data = bytes(64)
          elif len(report_data) < 64:
              report_data = report_data + bytes(64 - len(report_data))
          report_data = report_data[:64]

          report_name = f"quote_{uuid.uuid4().hex[:8]}"
          report_path = os.path.join(TSM_REPORT_PATH, report_name)

          try:
              os.makedirs(report_path, exist_ok=True)
              with open(os.path.join(report_path, "inblob"), "wb") as f:
                  f.write(report_data)
              with open(os.path.join(report_path, "outblob"), "rb") as f:
                  quote = f.read()
              return quote, report_data
          finally:
              try:
                  os.rmdir(report_path)
              except:
                  pass

      def extract_measurements(quote):
          """Extract measurements from TDX Quote v4."""
          # TDX Quote v4: Header (48) + Body with TD Report
          # TD Report in quote body at offset 48, measurements at:
          # MRTD: offset 48+128=176 (48 bytes)
          # RTMRs: offset 48+320=368 (4x48 bytes)
          if len(quote) < 560:
              return {}
          return {
              "mrtd": quote[176:224].hex(),
              "rtmr0": quote[368:416].hex(),
              "rtmr1": quote[416:464].hex(),
              "rtmr2": quote[464:512].hex(),
              "rtmr3": quote[512:560].hex(),
          }

      class TDXHandler(http.server.BaseHTTPRequestHandler):
          def log_message(self, format, *args):
              pass

          def send_json(self, code, data):
              self.send_response(code)
              self.send_header("Content-Type", "application/json")
              self.end_headers()
              self.wfile.write(json.dumps(data).encode())

          def do_GET(self):
              if self.path == "/status":
                  self.send_json(200, {"available": os.path.exists(TSM_REPORT_PATH), "tsm_path": TSM_REPORT_PATH})
              elif self.path == "/quote":
                  try:
                      quote, report_data = get_tdx_quote()
                      self.send_json(200, {
                          "quote": base64.b64encode(quote).decode(),
                          "quote_size": len(quote),
                          "report_data": base64.b64encode(report_data).decode(),
                          "measurements": extract_measurements(quote)
                      })
                  except Exception as e:
                      self.send_json(500, {"error": str(e)})
              else:
                  self.send_response(404)
                  self.end_headers()

          def do_POST(self):
              if self.path == "/quote":
                  try:
                      length = int(self.headers.get("Content-Length", 0))
                      body = json.loads(self.rfile.read(length)) if length else {}
                      report_data = base64.b64decode(body.get("reportData", "")) if body.get("reportData") else None
                      quote, used_report_data = get_tdx_quote(report_data)
                      self.send_json(200, {
                          "quote": base64.b64encode(quote).decode(),
                          "quote_size": len(quote),
                          "report_data": base64.b64encode(used_report_data).decode(),
                          "measurements": extract_measurements(quote)
                      })
                  except Exception as e:
                      self.send_json(500, {"error": str(e)})
              else:
                  self.send_response(404)
                  self.end_headers()

      if __name__ == "__main__":
          print(f"TDX Attestation Proxy on port {PORT}")
          http.server.HTTPServer(("0.0.0.0", PORT), TDXHandler).serve_forever()

  - path: /etc/systemd/system/tdx-attestation-proxy.service
    permissions: '0644'
    content: |
      [Unit]
      Description=TDX Attestation Proxy
      After=network.target

      [Service]
      Type=simple
      ExecStart=/usr/bin/python3 /opt/recording-oracle/tdx-attestation-proxy.py
      Restart=always

      [Install]
      WantedBy=multi-user.target

  - path: /opt/recording-oracle/.env
    permissions: '0600'
    content: |
      # Secrets for recording-oracle (replace in production)
      JWT_PRIVATE_KEY=-----BEGIN EC PRIVATE KEY-----\nMHcCAQEEIO3jow3dIM2HoetSGZySj4jOaGzL3/mqPn2qo4CLRSfloAoGCCqGSM49\nAwEHoUQDQgAEjJ0hc6Q+vK/Ko5LP3C8TDGZqFZtpP/iF6ATs+5vfLZ0LLX+yqzBU\nLydATxczxyUe5vxvXV11BhPfs17J2Rf52A==\n-----END EC PRIVATE KEY-----
      JWT_PUBLIC_KEY=-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEjJ0hc6Q+vK/Ko5LP3C8TDGZqFZtp\nP/iF6ATs+5vfLZ0LLX+yqzBULydATxczxyUe5vxvXV11BhPfs17J2Rf52A==\n-----END PUBLIC KEY-----
      AES_ENCRYPTION_KEY=E4MyMuBHDUNQa396GL3q8AClLPkg3JmV
      WEB3_PRIVATE_KEY=0x0000000000000000000000000000000000000000000000000000000000000001
      RPC_URL_POLYGON_AMOY=https://rpc-amoy.polygon.technology
      RPC_URL_LOCALHOST=http://localhost:8545
      ALCHEMY_API_KEY=demo

  - path: /opt/recording-oracle/docker-compose.yml
    permissions: '0644'
    content: |
      services:
        postgres:
          image: postgres:15-alpine
          environment:
            POSTGRES_USER: postgres
            POSTGRES_PASSWORD: postgres
            POSTGRES_DB: recording
          volumes:
            - postgres_data:/var/lib/postgresql/data
          healthcheck:
            test: ["CMD-SHELL", "pg_isready -U postgres"]
            interval: 5s
            timeout: 5s
            retries: 5

        minio:
          image: minio/minio:latest
          command: server /data --console-address ":9001"
          environment:
            MINIO_ROOT_USER: minioadmin
            MINIO_ROOT_PASSWORD: minioadmin
          volumes:
            - minio_data:/data
          healthcheck:
            test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
            interval: 5s
            timeout: 5s
            retries: 5

        minio-init:
          image: minio/mc:latest
          depends_on:
            minio:
              condition: service_healthy
          entrypoint: >
            /bin/sh -c "
              mc alias set myminio http://minio:9000 minioadmin minioadmin;
              mc mb --ignore-existing myminio/recordings;
              mc anonymous set public myminio/recordings;
              exit 0;
            "

        recording-oracle:
          image: {{ recording_oracle_image }}
          depends_on:
            postgres:
              condition: service_healthy
            minio:
              condition: service_healthy
          ports:
            - "{{ recording_oracle_port }}:{{ recording_oracle_port }}"
          extra_hosts:
            - "host.docker.internal:host-gateway"
          env_file:
            - .env
          environment:
            NODE_ENV: development
            HOST: 0.0.0.0
            PORT: "{{ recording_oracle_port }}"
            # Database
            POSTGRES_HOST: postgres
            POSTGRES_PORT: "5432"
            POSTGRES_USER: postgres
            POSTGRES_PASSWORD: postgres
            POSTGRES_DATABASE: recording
            POSTGRES_SSL: "false"
            # S3/Minio
            S3_ENDPOINT: minio
            S3_PORT: "9000"
            S3_ACCESS_KEY: minioadmin
            S3_SECRET_KEY: minioadmin
            S3_BUCKET: recordings
            S3_USE_SSL: "false"
            # TDX
            TDX_ATTESTATION_PROXY_URL: http://host.docker.internal:8081

      volumes:
        postgres_data:
        minio_data:

  - path: /etc/systemd/system/recording-oracle.service
    permissions: '0644'
    content: |
      [Unit]
      Description=Recording Oracle Stack
      After=docker.service
      Requires=docker.service

      [Service]
      Type=oneshot
      RemainAfterExit=yes
      WorkingDirectory=/opt/recording-oracle
      ExecStart=/usr/bin/docker compose up -d
      ExecStop=/usr/bin/docker compose down

      [Install]
      WantedBy=multi-user.target

runcmd:
  # Start TDX attestation proxy
  - systemctl daemon-reload
  - systemctl enable tdx-attestation-proxy
  - systemctl start tdx-attestation-proxy
  # Ensure docker is running
  - systemctl enable docker
  - systemctl start docker
  # Start recording oracle stack
  - systemctl enable recording-oracle
  - systemctl start recording-oracle

final_message: |
  Recording Oracle TDX VM is ready!

  TDX Attestation Proxy: http://localhost:8081
  Recording Oracle: http://localhost:{{ recording_oracle_port }}
  Minio Console: http://localhost:9001

  To check TDX status: curl http://localhost:8081/status
  To get TDX quote: curl http://localhost:8081/quote
